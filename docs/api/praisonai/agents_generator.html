<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>praisonai.agents_generator API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>praisonai.agents_generator</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="praisonai.agents_generator.disable_crewai_telemetry"><code class="name flex">
<span>def <span class="ident">disable_crewai_telemetry</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="praisonai.agents_generator.noop"><code class="name flex">
<span>def <span class="ident">noop</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="praisonai.agents_generator.AgentsGenerator"><code class="flex name class">
<span>class <span class="ident">AgentsGenerator</span></span>
<span>(</span><span>agent_file, framework, config_list, log_level=None, agent_callback=None, task_callback=None, agent_yaml=None, tools=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the AgentsGenerator object.</p>
<h2 id="parameters">Parameters</h2>
<p>agent_file (str): The path to the agent file.
framework (str): The framework to be used for the agents.
config_list (list): A list of configurations for the agents.
log_level (int, optional): The logging level to use. Defaults to logging.INFO.
agent_callback (callable, optional): A callback function to be executed after each agent step.
task_callback (callable, optional): A callback function to be executed after each tool run.
agent_yaml (str, optional): The content of the YAML file. Defaults to None.
tools (dict, optional): A dictionary containing the tools to be used for the agents. Defaults to None.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>agent_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the agent file.</dd>
<dt><strong><code>framework</code></strong> :&ensp;<code>str</code></dt>
<dd>The framework to be used for the agents.</dd>
<dt><strong><code>config_list</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of configurations for the agents.</dd>
<dt><strong><code>log_level</code></strong> :&ensp;<code>int</code></dt>
<dd>The logging level to use.</dd>
<dt><strong><code>agent_callback</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callback function to be executed after each agent step.</dd>
<dt><strong><code>task_callback</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callback function to be executed after each tool run.</dd>
<dt><strong><code>tools</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the tools to be used for the agents.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AgentsGenerator:
    def __init__(self, agent_file, framework, config_list, log_level=None, agent_callback=None, task_callback=None, agent_yaml=None, tools=None):
        &#34;&#34;&#34;
        Initialize the AgentsGenerator object.

        Parameters:
            agent_file (str): The path to the agent file.
            framework (str): The framework to be used for the agents.
            config_list (list): A list of configurations for the agents.
            log_level (int, optional): The logging level to use. Defaults to logging.INFO.
            agent_callback (callable, optional): A callback function to be executed after each agent step.
            task_callback (callable, optional): A callback function to be executed after each tool run.
            agent_yaml (str, optional): The content of the YAML file. Defaults to None.
            tools (dict, optional): A dictionary containing the tools to be used for the agents. Defaults to None.

        Attributes:
            agent_file (str): The path to the agent file.
            framework (str): The framework to be used for the agents.
            config_list (list): A list of configurations for the agents.
            log_level (int): The logging level to use.
            agent_callback (callable, optional): A callback function to be executed after each agent step.
            task_callback (callable, optional): A callback function to be executed after each tool run.
            tools (dict): A dictionary containing the tools to be used for the agents.
        &#34;&#34;&#34;
        self.agent_file = agent_file
        self.framework = framework
        self.config_list = config_list
        self.log_level = log_level
        self.agent_callback = agent_callback
        self.task_callback = task_callback
        self.agent_yaml = agent_yaml
        self.tools = tools or []  # Store tool class names as a list
        self.log_level = log_level or logging.getLogger().getEffectiveLevel()
        if self.log_level == logging.NOTSET:
            self.log_level = os.environ.get(&#39;LOGLEVEL&#39;, &#39;INFO&#39;).upper()
        
        logging.basicConfig(level=self.log_level, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(self.log_level)
        
    def is_function_or_decorated(self, obj):
        &#34;&#34;&#34;
        Checks if the given object is a function or has a __call__ method.

        Parameters:
            obj (object): The object to be checked.

        Returns:
            bool: True if the object is a function or has a __call__ method, False otherwise.
        &#34;&#34;&#34;
        return inspect.isfunction(obj) or hasattr(obj, &#39;__call__&#39;)

    def load_tools_from_module(self, module_path):
        &#34;&#34;&#34;
        Loads tools from a specified module path.

        Parameters:
            module_path (str): The path to the module containing the tools.

        Returns:
            dict: A dictionary containing the names of the tools as keys and the corresponding functions or objects as values.

        Raises:
            FileNotFoundError: If the specified module path does not exist.
        &#34;&#34;&#34;
        spec = importlib.util.spec_from_file_location(&#34;tools_module&#34;, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return {name: obj for name, obj in inspect.getmembers(module, self.is_function_or_decorated)}
    
    def load_tools_from_module_class(self, module_path):
        &#34;&#34;&#34;
        Loads tools from a specified module path containing classes that inherit from BaseTool or are part of langchain_community.tools package.

        Parameters:
            module_path (str): The path to the module containing the tools.

        Returns:
            dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.

        Raises:
            FileNotFoundError: If the specified module path does not exist.
        &#34;&#34;&#34;
        spec = importlib.util.spec_from_file_location(&#34;tools_module&#34;, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return {name: obj() for name, obj in inspect.getmembers(module, lambda x: inspect.isclass(x) and (x.__module__.startswith(&#39;langchain_community.tools&#39;) or issubclass(x, BaseTool)) and x is not BaseTool)}

    def load_tools_from_package(self, package_path):
        &#34;&#34;&#34;
        Loads tools from a specified package path containing modules with functions or classes.

        Parameters:
            package_path (str): The path to the package containing the tools.

        Returns:
            dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.

        Raises:
            FileNotFoundError: If the specified package path does not exist.

        This function iterates through all the .py files in the specified package path, excluding those that start with &#34;__&#34;. For each file, it imports the corresponding module and checks if it contains any functions or classes that can be loaded as tools. The function then returns a dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.
        &#34;&#34;&#34;
        tools_dict = {}
        for module_file in os.listdir(package_path):
            if module_file.endswith(&#39;.py&#39;) and not module_file.startswith(&#39;__&#39;):
                module_name = f&#34;{package_path.name}.{module_file[:-3]}&#34;  # Remove .py for import
                module = importlib.import_module(module_name)
                for name, obj in inspect.getmembers(module, self.is_function_or_decorated):
                    tools_dict[name] = obj
        return tools_dict

    def generate_crew_and_kickoff(self):
        &#34;&#34;&#34;
        Generates a crew of agents and initiates tasks based on the provided configuration.

        Parameters:
            agent_file (str): The path to the agent file.
            framework (str): The framework to be used for the agents.
            config_list (list): A list of configurations for the agents.

        Returns:
            str: The output of the tasks performed by the crew of agents.

        Raises:
            FileNotFoundError: If the specified agent file does not exist.

        This function first loads the agent configuration from the specified file. It then initializes the tools required for the agents based on the specified framework. If the specified framework is &#34;autogen&#34;, it loads the LLM configuration dynamically and creates an AssistantAgent for each role in the configuration. It then adds tools to the agents if specified in the configuration. Finally, it prepares tasks for the agents based on the configuration and initiates the tasks using the crew of agents. If the specified framework is not &#34;autogen&#34;, it creates a crew of agents and initiates tasks based on the configuration.
        &#34;&#34;&#34;
        if self.agent_yaml:
            config = yaml.safe_load(self.agent_yaml)
        else:
            if self.agent_file == &#39;/app/api:app&#39; or self.agent_file == &#39;api:app&#39;:
                self.agent_file = &#39;agents.yaml&#39;
            try:
                with open(self.agent_file, &#39;r&#39;) as f:
                    config = yaml.safe_load(f)
            except FileNotFoundError:
                print(f&#34;File not found: {self.agent_file}&#34;)
                return

        topic = config[&#39;topic&#39;]
        tools_dict = {
            &#39;CodeDocsSearchTool&#39;: CodeDocsSearchTool(),
            &#39;CSVSearchTool&#39;: CSVSearchTool(),
            &#39;DirectorySearchTool&#39;: DirectorySearchTool(),
            &#39;DOCXSearchTool&#39;: DOCXSearchTool(),
            &#39;DirectoryReadTool&#39;: DirectoryReadTool(),
            &#39;FileReadTool&#39;: FileReadTool(),
            # &#39;GithubSearchTool&#39;: GithubSearchTool(),
            # &#39;SeperDevTool&#39;: SeperDevTool(),
            &#39;TXTSearchTool&#39;: TXTSearchTool(),
            &#39;JSONSearchTool&#39;: JSONSearchTool(),
            &#39;MDXSearchTool&#39;: MDXSearchTool(),
            &#39;PDFSearchTool&#39;: PDFSearchTool(),
            # &#39;PGSearchTool&#39;: PGSearchTool(),
            &#39;RagTool&#39;: RagTool(),
            &#39;ScrapeElementFromWebsiteTool&#39;: ScrapeElementFromWebsiteTool(),
            &#39;ScrapeWebsiteTool&#39;: ScrapeWebsiteTool(),
            &#39;WebsiteSearchTool&#39;: WebsiteSearchTool(),
            &#39;XMLSearchTool&#39;: XMLSearchTool(),
            &#39;YoutubeChannelSearchTool&#39;: YoutubeChannelSearchTool(),
            &#39;YoutubeVideoSearchTool&#39;: YoutubeVideoSearchTool(),
        }
        
        # Add tools from class names
        for tool_class in self.tools:
            if isinstance(tool_class, type) and issubclass(tool_class, BaseTool):
                tool_name = tool_class.__name__
                tools_dict[tool_name] = tool_class()
                self.logger.debug(f&#34;Added tool: {tool_name}&#34;)
        
        root_directory = os.getcwd()
        tools_py_path = os.path.join(root_directory, &#39;tools.py&#39;)
        tools_dir_path = Path(root_directory) / &#39;tools&#39;
        
        if os.path.isfile(tools_py_path):
            tools_dict.update(self.load_tools_from_module_class(tools_py_path))
            self.logger.debug(&#34;tools.py exists in the root directory. Loading tools.py and skipping tools folder.&#34;)
        elif tools_dir_path.is_dir():
            tools_dict.update(self.load_tools_from_module_class(tools_dir_path))
            self.logger.debug(&#34;tools folder exists in the root directory&#34;)
        
        framework = self.framework or config.get(&#39;framework&#39;)

        agents = {}
        tasks = []
        if framework == &#34;autogen&#34;:
            # Load the LLM configuration dynamically
            # print(self.config_list)
            llm_config = {&#34;config_list&#34;: self.config_list}
            
            if agentops_exists:
                agentops.init(os.environ.get(&#34;AGENTOPS_API_KEY&#34;), tags=[&#34;autogen&#34;])
            # Assuming the user proxy agent is set up as per your requirements
            user_proxy = autogen.UserProxyAgent(
                name=&#34;User&#34;,
                human_input_mode=&#34;NEVER&#34;,
                is_termination_msg=lambda x: (x.get(&#34;content&#34;) or &#34;&#34;).rstrip().rstrip(&#34;.&#34;).lower().endswith(&#34;terminate&#34;) or &#34;TERMINATE&#34; in (x.get(&#34;content&#34;) or &#34;&#34;),
                code_execution_config={
                    &#34;work_dir&#34;: &#34;coding&#34;,
                    &#34;use_docker&#34;: False,
                },
                # additional setup for the user proxy agent
            )
            
            for role, details in config[&#39;roles&#39;].items():
                agent_name = details[&#39;role&#39;].format(topic=topic).replace(&#34;{topic}&#34;, topic)
                agent_goal = details[&#39;goal&#39;].format(topic=topic)
                # Creating an AssistantAgent for each role dynamically
                agents[role] = autogen.AssistantAgent(
                    name=agent_name,
                    llm_config=llm_config,
                    system_message=details[&#39;backstory&#39;].format(topic=topic)+&#34;. Must Reply \&#34;TERMINATE\&#34; in the end when everything is done.&#34;,
                )
                for tool in details.get(&#39;tools&#39;, []):
                    if tool in tools_dict:
                        try:
                            tool_class = globals()[f&#39;autogen_{type(tools_dict[tool]).__name__}&#39;]
                            print(f&#34;Found {tool_class.__name__} for {tool}&#34;)
                        except KeyError:
                            print(f&#34;Warning: autogen_{type(tools_dict[tool]).__name__} function not found. Skipping this tool.&#34;)
                            continue
                        tool_class(agents[role], user_proxy)

                # Preparing tasks for initiate_chats
                for task_name, task_details in details.get(&#39;tasks&#39;, {}).items():
                    description_filled = task_details[&#39;description&#39;].format(topic=topic)
                    expected_output_filled = task_details[&#39;expected_output&#39;].format(topic=topic)
                    
                    chat_task = {
                        &#34;recipient&#34;: agents[role],
                        &#34;message&#34;: description_filled,
                        &#34;summary_method&#34;: &#34;last_msg&#34;, 
                        # Additional fields like carryover can be added based on dependencies
                    }
                    tasks.append(chat_task)
            response = user_proxy.initiate_chats(tasks)
            result = &#34;### Output ###\n&#34;+response[-1].summary if hasattr(response[-1], &#39;summary&#39;) else &#34;&#34;
            if agentops_exists:
                agentops.end_session(&#34;Success&#34;)
        else: # framework=crewai
            if agentops_exists:
                agentops.init(os.environ.get(&#34;AGENTOPS_API_KEY&#34;), tags=[&#34;crewai&#34;])
            
            tasks_dict = {}
            
            for role, details in config[&#39;roles&#39;].items():
                role_filled = details[&#39;role&#39;].format(topic=topic)
                goal_filled = details[&#39;goal&#39;].format(topic=topic)
                backstory_filled = details[&#39;backstory&#39;].format(topic=topic)
                
                # Adding tools to the agent if exists
                agent_tools = [tools_dict[tool] for tool in details.get(&#39;tools&#39;, []) if tool in tools_dict]
                
                llm_model = details.get(&#39;llm&#39;)  # Get the llm configuration
                if llm_model:
                    llm = PraisonAIModel(
                        model=llm_model.get(&#34;model&#34;, os.environ.get(&#34;MODEL_NAME&#34;, &#34;openai/gpt-4o&#34;)),
                    ).get_model()
                else:
                    llm = PraisonAIModel().get_model()

                function_calling_llm_model = details.get(&#39;function_calling_llm&#39;)
                if function_calling_llm_model:
                    function_calling_llm = PraisonAIModel(
                        model=function_calling_llm_model.get(&#34;model&#34;, os.environ.get(&#34;MODEL_NAME&#34;, &#34;openai/gpt-4o&#34;)),
                    ).get_model()
                else:
                    function_calling_llm = PraisonAIModel().get_model()
                
                agent = Agent(
                    role=role_filled, 
                    goal=goal_filled, 
                    backstory=backstory_filled, 
                    tools=agent_tools, 
                    allow_delegation=details.get(&#39;allow_delegation&#39;, False),
                    llm=llm,
                    function_calling_llm=function_calling_llm,
                    max_iter=details.get(&#39;max_iter&#39;, 15),
                    max_rpm=details.get(&#39;max_rpm&#39;),
                    max_execution_time=details.get(&#39;max_execution_time&#39;),
                    verbose=details.get(&#39;verbose&#39;, True),
                    cache=details.get(&#39;cache&#39;, True),
                    system_template=details.get(&#39;system_template&#39;),
                    prompt_template=details.get(&#39;prompt_template&#39;),
                    response_template=details.get(&#39;response_template&#39;),
                )
                
                # Set agent callback if provided
                if self.agent_callback:
                    agent.step_callback = self.agent_callback

                agents[role] = agent

                for task_name, task_details in details.get(&#39;tasks&#39;, {}).items():
                    description_filled = task_details[&#39;description&#39;].format(topic=topic)
                    expected_output_filled = task_details[&#39;expected_output&#39;].format(topic=topic)

                    task = Task(
                        description=description_filled,  # Clear, concise statement of what the task entails
                        expected_output=expected_output_filled,  # Detailed description of what task&#39;s completion looks like
                        agent=agent,  # The agent responsible for the task
                        tools=task_details.get(&#39;tools&#39;, []),  # Functions or capabilities the agent can utilize
                        async_execution=task_details.get(&#39;async_execution&#39;) if task_details.get(&#39;async_execution&#39;) is not None else False,  # Execute asynchronously if set
                        context=[], ## TODO: 
                        config=task_details.get(&#39;config&#39;) if task_details.get(&#39;config&#39;) is not None else {},  # Additional configuration details
                        output_json=task_details.get(&#39;output_json&#39;) if task_details.get(&#39;output_json&#39;) is not None else None,  # Outputs a JSON object
                        output_pydantic=task_details.get(&#39;output_pydantic&#39;) if task_details.get(&#39;output_pydantic&#39;) is not None else None,  # Outputs a Pydantic model object
                        output_file=task_details.get(&#39;output_file&#39;) if task_details.get(&#39;output_file&#39;) is not None else &#34;&#34;,  # Saves the task output to a file
                        callback=task_details.get(&#39;callback&#39;) if task_details.get(&#39;callback&#39;) is not None else None,  # Python callable executed with the task&#39;s output
                        human_input=task_details.get(&#39;human_input&#39;) if task_details.get(&#39;human_input&#39;) is not None else False,  # Indicates if the task requires human feedback
                        create_directory=task_details.get(&#39;create_directory&#39;) if task_details.get(&#39;create_directory&#39;) is not None else False  # Indicates if a directory needs to be created
                    )
                    
                    # Set tool callback if provided
                    if self.task_callback:
                        task.callback = self.task_callback

                    tasks.append(task)
                    tasks_dict[task_name] = task
            
            for role, details in config[&#39;roles&#39;].items():
                for task_name, task_details in details.get(&#39;tasks&#39;, {}).items():
                    task = tasks_dict[task_name]
                    context_tasks = [tasks_dict[ctx] for ctx in task_details.get(&#39;context&#39;, []) if ctx in tasks_dict]
                    task.context = context_tasks

            crew = Crew(
                agents=list(agents.values()),
                tasks=tasks,
                verbose=2
            )
            
            self.logger.debug(&#34;Final Crew Configuration:&#34;)
            self.logger.debug(f&#34;Agents: {crew.agents}&#34;)
            self.logger.debug(f&#34;Tasks: {crew.tasks}&#34;)

            response = crew.kickoff()
            result = f&#34;### Task Output ###\n{response}&#34;
            if agentops_exists:
                agentops.end_session(&#34;Success&#34;)
        return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="praisonai.agents_generator.AgentsGenerator.generate_crew_and_kickoff"><code class="name flex">
<span>def <span class="ident">generate_crew_and_kickoff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a crew of agents and initiates tasks based on the provided configuration.</p>
<h2 id="parameters">Parameters</h2>
<p>agent_file (str): The path to the agent file.
framework (str): The framework to be used for the agents.
config_list (list): A list of configurations for the agents.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The output of the tasks performed by the crew of agents.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified agent file does not exist.</dd>
</dl>
<p>This function first loads the agent configuration from the specified file. It then initializes the tools required for the agents based on the specified framework. If the specified framework is "autogen", it loads the LLM configuration dynamically and creates an AssistantAgent for each role in the configuration. It then adds tools to the agents if specified in the configuration. Finally, it prepares tasks for the agents based on the configuration and initiates the tasks using the crew of agents. If the specified framework is not "autogen", it creates a crew of agents and initiates tasks based on the configuration.</p></div>
</dd>
<dt id="praisonai.agents_generator.AgentsGenerator.is_function_or_decorated"><code class="name flex">
<span>def <span class="ident">is_function_or_decorated</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given object is a function or has a <strong>call</strong> method.</p>
<h2 id="parameters">Parameters</h2>
<p>obj (object): The object to be checked.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the object is a function or has a <strong>call</strong> method, False otherwise.</dd>
</dl></div>
</dd>
<dt id="praisonai.agents_generator.AgentsGenerator.load_tools_from_module"><code class="name flex">
<span>def <span class="ident">load_tools_from_module</span></span>(<span>self, module_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads tools from a specified module path.</p>
<h2 id="parameters">Parameters</h2>
<p>module_path (str): The path to the module containing the tools.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the names of the tools as keys and the corresponding functions or objects as values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified module path does not exist.</dd>
</dl></div>
</dd>
<dt id="praisonai.agents_generator.AgentsGenerator.load_tools_from_module_class"><code class="name flex">
<span>def <span class="ident">load_tools_from_module_class</span></span>(<span>self, module_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads tools from a specified module path containing classes that inherit from BaseTool or are part of langchain_community.tools package.</p>
<h2 id="parameters">Parameters</h2>
<p>module_path (str): The path to the module containing the tools.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified module path does not exist.</dd>
</dl></div>
</dd>
<dt id="praisonai.agents_generator.AgentsGenerator.load_tools_from_package"><code class="name flex">
<span>def <span class="ident">load_tools_from_package</span></span>(<span>self, package_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads tools from a specified package path containing modules with functions or classes.</p>
<h2 id="parameters">Parameters</h2>
<p>package_path (str): The path to the package containing the tools.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified package path does not exist.</dd>
</dl>
<p>This function iterates through all the .py files in the specified package path, excluding those that start with "__". For each file, it imports the corresponding module and checks if it contains any functions or classes that can be loaded as tools. The function then returns a dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="praisonai" href="index.html">praisonai</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="praisonai.agents_generator.disable_crewai_telemetry" href="#praisonai.agents_generator.disable_crewai_telemetry">disable_crewai_telemetry</a></code></li>
<li><code><a title="praisonai.agents_generator.noop" href="#praisonai.agents_generator.noop">noop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="praisonai.agents_generator.AgentsGenerator" href="#praisonai.agents_generator.AgentsGenerator">AgentsGenerator</a></code></h4>
<ul class="">
<li><code><a title="praisonai.agents_generator.AgentsGenerator.generate_crew_and_kickoff" href="#praisonai.agents_generator.AgentsGenerator.generate_crew_and_kickoff">generate_crew_and_kickoff</a></code></li>
<li><code><a title="praisonai.agents_generator.AgentsGenerator.is_function_or_decorated" href="#praisonai.agents_generator.AgentsGenerator.is_function_or_decorated">is_function_or_decorated</a></code></li>
<li><code><a title="praisonai.agents_generator.AgentsGenerator.load_tools_from_module" href="#praisonai.agents_generator.AgentsGenerator.load_tools_from_module">load_tools_from_module</a></code></li>
<li><code><a title="praisonai.agents_generator.AgentsGenerator.load_tools_from_module_class" href="#praisonai.agents_generator.AgentsGenerator.load_tools_from_module_class">load_tools_from_module_class</a></code></li>
<li><code><a title="praisonai.agents_generator.AgentsGenerator.load_tools_from_package" href="#praisonai.agents_generator.AgentsGenerator.load_tools_from_package">load_tools_from_package</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
